.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "sglr-api 3"
.TH sglr-api 3 "2002-07-21" "3.14" "Meta-Environment Documentation"
.SH "NAME"
\&\fBSGinitParser\fR, \fBSGopenLanguageFromTerm\fR, \fBSGopenLanguage\fR, \fBSGcloseLanguage\fR, \fBSGreOpenLanguage\fR, \fBSGparseString\fR, \fBSGparseStringAsAsFix2\fR, \fBSGparseStringAsAsFix1\fR, \fBSGparseFile\fR, \fBSGtermToFile\fR, \fBSGparseFileUsingTable\fR, \fBSGisParseTree\fR, \fBSGisParseError\fR \- an interface to the Scannerless Generalized LR parser
.SH "LIBRARY"
.IX Header "LIBRARY"
\&\s-1SGLR\s0 library (libsglr, \-lsglr)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Sh "\fBDefinitions\fP"
.IX Subsection "Definitions"
.IP "#include <sglr.h>" 4
.IX Item "#include <sglr.h>"
.Sh "\fB\s-1API\s0 Functions\fP"
.IX Subsection "API Functions"
.PD 0
.IP "void  \fBSGinitParser\fR(ATbool toolbus_mode);" 4
.IX Item "void  SGinitParser(ATbool toolbus_mode);"
.IP "ATerm \fBSGopenlanguageFromTerm\fR(char *errpre, language lang, ATerm tbl);" 4
.IX Item "ATerm SGopenlanguageFromTerm(char *errpre, language lang, ATerm tbl);"
.IP "ATerm \fBSGopenlanguage\fR(char *errpre, language lang, char *tblfil);" 4
.IX Item "ATerm SGopenlanguage(char *errpre, language lang, char *tblfil);"
.IP "ATerm \fBSGcloselanguage\fR(char *errpre, language lang);" 4
.IX Item "ATerm SGcloselanguage(char *errpre, language lang);"
.IP "ATerm \fBSGreOpenlanguage\fR(char *errpre, language lang, char *tblfil);" 4
.IX Item "ATerm SGreOpenlanguage(char *errpre, language lang, char *tblfil);"
.IP "ATerm \fBSGgetTopSymbols\fR(language lang);" 4
.IX Item "ATerm SGgetTopSymbols(language lang);"
.IP "ATerm \fBSGparseString\fR(language lang, char *sort, char *str);" 4
.IX Item "ATerm SGparseString(language lang, char *sort, char *str);"
.IP "ATerm \fBSGparseStringAsAsFix2\fR(language lang, char *sort, char *str);" 4
.IX Item "ATerm SGparseStringAsAsFix2(language lang, char *sort, char *str);"
.IP "ATerm \fBSGparseStringAsAsFix1\fR(language lang, char *sort, char *str);" 4
.IX Item "ATerm SGparseStringAsAsFix1(language lang, char *sort, char *str);"
.IP "ATerm \fBSGparseFile\fR(char *errpre, language lang, char *sort, char *infil);" 4
.IX Item "ATerm SGparseFile(char *errpre, language lang, char *sort, char *infil);"
.IP "ATerm \fBSGparseFileUsingTable\fR(char *errpre, char *tblfil, char *sort, char *infil, char *outfil);" 4
.IX Item "ATerm SGparseFileUsingTable(char *errpre, char *tblfil, char *sort, char *infil, char *outfil);"
.IP "ATerm \fBSGtermToFile\fR(char *errpre, ATerm frst, char *outfil);" 4
.IX Item "ATerm SGtermToFile(char *errpre, ATerm frst, char *outfil);"
.IP "ATbool \fBSGisParseTree\fR(ATerm frst);" 4
.IX Item "ATbool SGisParseTree(ATerm frst);"
.IP "ATBool \fBSGisParseError\fR(ATerm frst);" 4
.IX Item "ATBool SGisParseError(ATerm frst);"
.PD
.Sh "\fBOperating Mode Macros\fP"
.IX Subsection "Operating Mode Macros"
.IP "ATbool \fB\s-1SG_VERBOSE\s0\fR;  \fB\s-1SG_VERBOSE_ON\s0\fR(), \fB\s-1SG_VERBOSE_OFF\s0\fR()" 4
.IX Item "ATbool SG_VERBOSE;  SG_VERBOSE_ON(), SG_VERBOSE_OFF()"
.PD 0
.IP "ATbool \fB\s-1SG_DEBUG\s0\fR;  \fB\s-1SG_DEBUG_ON\s0\fR(), \fB\s-1SG_DEBUG_OFF\s0\fR()" 4
.IX Item "ATbool SG_DEBUG;  SG_DEBUG_ON(), SG_DEBUG_OFF()"
.IP "ATbool \fB\s-1SG_SHOWSTAT\s0\fR;  \fB\s-1SG_SHOWSTAT_ON\s0\fR(), \fB\s-1SG_SHOWSTAT_OFF\s0\fR()" 4
.IX Item "ATbool SG_SHOWSTAT;  SG_SHOWSTAT_ON(), SG_SHOWSTAT_OFF()"
.IP "ATbool \fB\s-1SG_OUTPUT\s0\fR;  \fB\s-1SG_OUTPUT_ON\s0\fR(), \fB\s-1SG_OUTPUT_OFF\s0\fR()" 4
.IX Item "ATbool SG_OUTPUT;  SG_OUTPUT_ON(), SG_OUTPUT_OFF()"
.IP "ATbool \fB\s-1SG_ASFIX1\s0\fR;  \fB\s-1SG_ASFIX1_ON\s0\fR(), \fB\s-1SG_ASFIX1_OFF\s0\fR()" 4
.IX Item "ATbool SG_ASFIX1;  SG_ASFIX1_ON(), SG_ASFIX1_OFF()"
.IP "ATbool \fB\s-1SG_BINARY\s0\fR;  \fB\s-1SG_BINARY_ON\s0\fR(), \fB\s-1SG_BINARY_OFF\s0\fR()" 4
.IX Item "ATbool SG_BINARY;  SG_BINARY_ON(), SG_BINARY_OFF()"
.IP "ATbool \fB\s-1SG_FILTER\s0\fR;  \fB\s-1SG_FILTER_ON\s0\fR(), \fB\s-1SG_FILTER_OFF\s0\fR()" 4
.IX Item "ATbool SG_FILTER;  SG_FILTER_ON(), SG_FILTER_OFF()"
.IP "ATbool \fB\s-1SG_FILTER_ASSOCIATIVITY\s0\fR; \fB\s-1SG_FILTER_ASSOCIATIVITY_ON\s0\fR(), \fB\s-1SG_FILTER_ASSOCIATIVITY_OFF\s0\fR" 4
.IX Item "ATbool SG_FILTER_ASSOCIATIVITY; SG_FILTER_ASSOCIATIVITY_ON(), SG_FILTER_ASSOCIATIVITY_OFF"
.IP "ATbool \fB\s-1SG_FILTER_DIRECTEAGERNESS\s0\fR; \fB\s-1SG_FILTER_DIRECTEAGERNESS_ON\s0\fR(), \fB\s-1SG_FILTER_DIRECTEAGERNESS_OFF\s0\fR" 4
.IX Item "ATbool SG_FILTER_DIRECTEAGERNESS; SG_FILTER_DIRECTEAGERNESS_ON(), SG_FILTER_DIRECTEAGERNESS_OFF"
.IP "ATbool \fB\s-1SG_FILTER_EAGERNESS\s0\fR; \fB\s-1SG_FILTER_EAGERNESS_ON\s0\fR(), \fB\s-1SG_FILTER_EAGERNESS_OFF\s0\fR" 4
.IX Item "ATbool SG_FILTER_EAGERNESS; SG_FILTER_EAGERNESS_ON(), SG_FILTER_EAGERNESS_OFF"
.IP "ATbool \fB\s-1SG_FILTER_INJECTIONCOUNT\s0\fR; \fB\s-1SG_FILTER_INJECTIONCOUNT_ON\s0\fR(), \fB\s-1SG_FILTER_INJECTIONCOUNT_OFF\s0\fR" 4
.IX Item "ATbool SG_FILTER_INJECTIONCOUNT; SG_FILTER_INJECTIONCOUNT_ON(), SG_FILTER_INJECTIONCOUNT_OFF"
.IP "ATbool \fB\s-1SG_FILTER_PRIORITY\s0\fR; \fB\s-1SG_FILTER_PRIORITY_ON\s0\fR(), \fB\s-1SG_FILTER_PRIORITY_OFF\s0\fR" 4
.IX Item "ATbool SG_FILTER_PRIORITY; SG_FILTER_PRIORITY_ON(), SG_FILTER_PRIORITY_OFF"
.IP "ATbool \fB\s-1SG_FILTER_REJECT\s0\fR; \fB\s-1SG_FILTER_REJECT_ON\s0\fR(), \fB\s-1SG_FILTER_REJECT_OFF\s0\fR" 4
.IX Item "ATbool SG_FILTER_REJECT; SG_FILTER_REJECT_ON(), SG_FILTER_REJECT_OFF"
.PD
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fB\s-1SGLR\s0\fR \s-1API\s0 offers high-level support for parsing functionality.
.PP
A few key concepts: in order to parse an input term, a parse table for
the language in which the term is supposed to be written must be
present.  A database of parse tables is maintained for that purpose.
In general, the user first makes sure the appropriate parse table for
some language L is opened; after that, terms can be parsed over that
language L.
.PP
As a result, either a parse error or a parse forest will be returned.
Parse forests can be written to a file.
.PP
The functions in the \s-1API\s0 that return an \f(CW\*(C`ATerm\*(C'\fR will return \f(CW\*(C`NULL\*(C'\fR on
an operational error; bear in mind that a successful parse that
stumbles upon a syntax error in the input term will produce an error
term rather than \f(CW\*(C`NULL\*(C'\fR.  Functions for checking parse results are
therefore also provided.
.PP
Throughout the interface, a  \f(CW\*(C`errpre\*(C'\fR argument specifies a prefix that
is used in contexts where an error message is returned to the user.  It
is typically instantiated with the toolname, making it possible to
identify the source of any occurring error message in a possibly
complex toolchain.
.SH "USAGE"
.IX Header "USAGE"
.Sh "\fB\s-1API\s0 Functions\fP"
.IX Subsection "API Functions"
.ie n .IP "\fBSGinitParser\fR will make the parsing routines operate in default mode; ""toolbus_mode"" determines whether or not to run as a ToolBus application." 4
.el .IP "\fBSGinitParser\fR will make the parsing routines operate in default mode; \f(CWtoolbus_mode\fR determines whether or not to run as a ToolBus application." 4
.IX Item "SGinitParser will make the parsing routines operate in default mode; toolbus_mode determines whether or not to run as a ToolBus application."
.PD 0
.ie n .IP "The \fBSGopenLanguageFromTerm\fR and \fBSGopenLanguage\fR functions make a language available.  The language is registered under the name of the ""name""\fR argument; it is available for later use (i.e. can be retrieved from the parse table database) by that name. \fBSGopenLanguageFromTerm\fR uses the parse table, represented as an \f(CW""ATerm""\fR, from the \f(CW""tbl""\fR argument; \fBSGopenLanguage\fR reads the parse table from the file that is named by the \f(CW""tblfil"" argument." 4
.el .IP "The \fBSGopenLanguageFromTerm\fR and \fBSGopenLanguage\fR functions make a language available.  The language is registered under the name of the \f(CWname\fR argument; it is available for later use (i.e. can be retrieved from the parse table database) by that name. \fBSGopenLanguageFromTerm\fR uses the parse table, represented as an \f(CWATerm\fR, from the \f(CWtbl\fR argument; \fBSGopenLanguage\fR reads the parse table from the file that is named by the \f(CWtblfil\fR argument." 4
.IX Item "The SGopenLanguageFromTerm and SGopenLanguage functions make a language available.  The language is registered under the name of the name argument; it is available for later use (i.e. can be retrieved from the parse table database) by that name. SGopenLanguageFromTerm uses the parse table, represented as an ATerm, from the tbl argument; SGopenLanguage reads the parse table from the file that is named by the tblfil argument."
.PD
If a parse table of the indicated name is already present, the existing
table will be used.  The \fBSGreOpenlanguage\fR, used identically to
\&\fBSGopenlanguage\fR, replaces eventually existing parse tables by the
table contained in the named file.
.IP "The \fBSGgetTopSymbols\fR function returns the symbols that are defined as start symbols in the requested language." 4
.IX Item "The SGgetTopSymbols function returns the symbols that are defined as start symbols in the requested language."
.PD 0
.ie n .IP "There are several ways of parsing an input term.  Assuming it does not contain ""NULL""\fR characters, it can be represented as a string. Such a string can then be parsed using the \fBSGparseString...\fR routines. The \f(CW""lang""\fR argument is a named language to parse the input term with; optionally, an explicit top sort to be produced by the parser can be specified using the \f(CW""sort""\fR argument.  The term to parse is contained as a string in \f(CW""str""\fR.  The \fBAsAsFix2\fR and \fBAsAsFix1 variants can be used to obtain parse trees in AsFix2 and AsFix1 results, respectively; note that AsFix1 can contain parse trees only." 4
.el .IP "There are several ways of parsing an input term.  Assuming it does not contain \f(CWNULL\fR characters, it can be represented as a string. Such a string can then be parsed using the \fBSGparseString...\fR routines. The \f(CWlang\fR argument is a named language to parse the input term with; optionally, an explicit top sort to be produced by the parser can be specified using the \f(CWsort\fR argument.  The term to parse is contained as a string in \f(CWstr\fR.  The \fBAsAsFix2\fR and \fBAsAsFix1\fR variants can be used to obtain parse trees in AsFix2 and AsFix1 results, respectively; note that AsFix1 can contain parse trees only." 4
.IX Item "There are several ways of parsing an input term.  Assuming it does not contain NULL characters, it can be represented as a string. Such a string can then be parsed using the SGparseString... routines. The lang argument is a named language to parse the input term with; optionally, an explicit top sort to be produced by the parser can be specified using the sort argument.  The term to parse is contained as a string in str.  The AsAsFix2 and AsAsFix1 variants can be used to obtain parse trees in AsFix2 and AsFix1 results, respectively; note that AsFix1 can contain parse trees only."
.ie n .IP "File-based parsing is provided by the \fBSGparseFile\fR and \fBSGparseFileUsingTable\fR functions.  In both functions, ""sort"" \*(-- again, optional \*(-- specifies the top sort the parse must produce." 4
.el .IP "File-based parsing is provided by the \fBSGparseFile\fR and \fBSGparseFileUsingTable\fR functions.  In both functions, \f(CWsort\fR \*(-- again, optional \*(-- specifies the top sort the parse must produce." 4
.IX Item "File-based parsing is provided by the SGparseFile and SGparseFileUsingTable functions.  In both functions, sort  again, optional  specifies the top sort the parse must produce."
.PD
For \fBSGparseFile\fR, the term contained in named input file \f(CW\*(C`infil\*(C'\fR
is parsed over the parse table as previously opened and registered
by the name \f(CW\*(C`lang\*(C'\fR.
.Sp
\&\fBSGparseFileUsingTable\fR uses a parse table contained in \f(CW\*(C`tblfil\*(C'\fR
to parse the term contained in the named file \f(CW\*(C`infil\*(C'\fR, and writes
output to the named file \f(CW\*(C`outfil\*(C'\fR.
.ie n .IP "After parsing, \fBSGtermToFile\fR writes the parse forest in ""frst""\fR to the output file named \f(CW""outfil""." 4
.el .IP "After parsing, \fBSGtermToFile\fR writes the parse forest in \f(CWfrst\fR to the output file named \f(CWoutfil\fR." 4
.IX Item "After parsing, SGtermToFile writes the parse forest in frst to the output file named outfil."
.PD 0
.ie n .IP "The boolean functions \fBSGisParseTree\fR and \fBSGisParseError\fR inspect an ""ATerm"" and will return whether or not it contains a parsetree, resp. a parse error." 4
.el .IP "The boolean functions \fBSGisParseTree\fR and \fBSGisParseError\fR inspect an \f(CWATerm\fR and will return whether or not it contains a parsetree, resp. a parse error." 4
.IX Item "The boolean functions SGisParseTree and SGisParseError inspect an ATerm and will return whether or not it contains a parsetree, resp. a parse error."
.PD
.Sh "\fBOperating Mode Macros\fP"
.IX Subsection "Operating Mode Macros"
A number of macros influence the parsing process.  The following naming
convention is used:  use \f(CW\*(C`SG_XXX\*(C'\fR as a variable to check whether
option \f(CW\*(C`XXX\*(C'\fR is enabled; use \f(CW\*(C`SG_XXX_ON()\*(C'\fR to enable and
\&\f(CW\*(C`SG_XXX_OFF()\*(C'\fR to enable or disable option \s-1XXX\s0, respectively.
.IP "\fB\s-1SG_VERBOSE\s0\fR indicates whether or not parsing is performed in verbose mode;  \fB\s-1SG_VERBOSE_ON\s0\fR() switches into and \fB\s-1SG_VERBOSE_OFF\s0\fR() out of verbose operating mode." 4
.IX Item "SG_VERBOSE indicates whether or not parsing is performed in verbose mode;  SG_VERBOSE_ON() switches into and SG_VERBOSE_OFF() out of verbose operating mode."
.PD 0
.IP "With \fB\s-1SG_DEBUG\s0\fR on, debugging information is written to disk. \fB\s-1SG_DEBUG_ON\s0\fR() enables and \fB\s-1SG_DEBUG_OFF\s0\fR() disables this." 4
.IX Item "With SG_DEBUG on, debugging information is written to disk. SG_DEBUG_ON() enables and SG_DEBUG_OFF() disables this."
.IP "When using \fB\s-1SG_SHOWSTAT\s0\fR, some run-time statistics are collected.  It is switched on by \fB\s-1SG_SHOWSTAT_ON\s0\fR() and off by \fB\s-1SG_SHOWSTAT_OFF\s0\fR()." 4
.IX Item "When using SG_SHOWSTAT, some run-time statistics are collected.  It is switched on by SG_SHOWSTAT_ON() and off by SG_SHOWSTAT_OFF()."
.IP "Unless \fB\s-1SG_OUTPUT\s0\fR is on (which it is by default) no output is generated.  In effect, a (fast) accepting/rejecting parser can be obtained by disabling output.  Switch it on using \fB\s-1SG_OUTPUT_ON\s0\fR(), off using \fB\s-1SG_OUTPUT_OFF\s0\fR()." 4
.IX Item "Unless SG_OUTPUT is on (which it is by default) no output is generated.  In effect, a (fast) accepting/rejecting parser can be obtained by disabling output.  Switch it on using SG_OUTPUT_ON(), off using SG_OUTPUT_OFF()."
.IP "If you set \fB\s-1SG_ASFIX1\s0\fR, the parse result will be represented in AsFix1 format, if possible.  By default, AsFix2 format is used. \fB\s-1SG_ASFIX1_ON\s0\fR() and \fB\s-1SG_ASFIX1_OFF\s0\fR() perform the obvious task; for convenience, \fB\s-1SG_ASFIX2\s0\fR, \fB\s-1SG_ASFIX2_ON\s0\fR(), and \fB\s-1SG_ASFIX2_OFF\s0\fR() are also provided." 4
.IX Item "If you set SG_ASFIX1, the parse result will be represented in AsFix1 format, if possible.  By default, AsFix2 format is used. SG_ASFIX1_ON() and SG_ASFIX1_OFF() perform the obvious task; for convenience, SG_ASFIX2, SG_ASFIX2_ON(), and SG_ASFIX2_OFF() are also provided."
.IP "\fB\s-1SG_BINARY\s0\fR determines whether terms are written in binary (shared) format, or in textual format when doing file I/O.  By default, the shared, binary format is used.  \fB\s-1SG_BINARY_ON\s0\fR() and \fB\s-1SG_BINARY_OFF\s0\fR() act as should be expected." 4
.IX Item "SG_BINARY determines whether terms are written in binary (shared) format, or in textual format when doing file I/O.  By default, the shared, binary format is used.  SG_BINARY_ON() and SG_BINARY_OFF() act as should be expected."
.IP "The \fB\s-1SG_FILTER\s0\fR option determines whether or not the parser applies a few common disambiguation strategies: subtree preference filtering, multiset filtering, and injection count filtering.  By default, filtering is applied; use \fB\s-1SG_FILTER_ON\s0\fR() to enable, \fB\s-1SG_FILTER_OFF\s0\fR() to disable all filters. If filtering is enabled, each filter can be toggled specifically also." 4
.IX Item "The SG_FILTER option determines whether or not the parser applies a few common disambiguation strategies: subtree preference filtering, multiset filtering, and injection count filtering.  By default, filtering is applied; use SG_FILTER_ON() to enable, SG_FILTER_OFF() to disable all filters. If filtering is enabled, each filter can be toggled specifically also."
.PD
These specific toggles are supposed to be used for debugging purposes only.
So, do not use these options to tweak your language implementations! It is
highly probable that there will be no backward compatibility for them in 
future versions.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\&  #include <sglr.h>
.Ve
.PP
.Vb 2
\&  #define ME "MyParser"
\&  #define L  "MyLanguageReferenceName"
.Ve
.PP
.Vb 4
\&  int main(int argc, char **argv)
\&  {
\&    ATerm bottomOfStack;
\&    ATerm forest;
.Ve
.PP
.Vb 1
\&    if(argc != 4) exit(1);
.Ve
.PP
.Vb 1
\&    ATinit(0, NULL, &bottomOfStack);
.Ve
.PP
.Vb 1
\&    SGinitParser(ATfalse);
.Ve
.PP
.Vb 8
\&    if(!SGopenLanguage(ME, L, argv[1])) {
\&      fprintf(stderr, "error opening language %s (in %s)\en", L, argv[1]);
\&      exit(2);
\&    }
\&    if(!(forest = SGparseFile(ME, L, NULL, argv[2]))) {
\&      fprintf(stderr, "error parsing %s (over %s)\en", argv[2], L);
\&      exit(3);
\&    }
.Ve
.PP
.Vb 5
\&    fprintf(stdout, "Parse successful, writing %s\en", argv[3]);
\&    SG_BINARY_OFF();  /*  Make output to `-' (stdout) safe  */
\&    SGtermToFile(ME, forest, argv[3]);
\&    return 0;
\&  }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
sglr, tree2dot
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
None.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jeroen Scheerder <js@cwi.nl>
