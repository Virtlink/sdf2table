.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SGLR 1"
.TH SGLR 1 "2001-08-20" "3.14" "Meta-Environment Documentation"
.SH "NAME"
SGLR \- the Scannerless Generalized LR parser
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBsglr\fR \-\fBp\fR file [\-\fB2?AbcdhlmnstvV\fR] [\-\fBf\fR[adeirp]] [\-\fBi\fR \fIfile\fR] [\-\fBo\fR \fIfile\fR] [\-\fBs\fR \fIsort\fR]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fBsglr\fR parser uses a specified \fIparse table\fR to parse an \fIinput file\fR.
After a successful parse, the resulting parse forest is written to an
\&\fIoutput file\fR.
.PP
A number of options can be supplied; these are as follows:
.IP "\-\fB2\fR" 4
.IX Item "-2"
Generate AsFix2 output format.  
.IP "\-\fBA\fR" 4
.IX Item "-A"
Ambiguities are treated as errors.
.IP "\-\fBb\fR, \-\fBt\fR" 4
.IX Item "-b, -t"
Choose between binary (\fBb\fR) and plaintext (\fBt\fR) output formats.  Default
is binary output.
.IP "\-\fBc\fR" 4
.IX Item "-c"
Toggles cycle detection (on by default).
.IP "\-\fBd\fR" 4
.IX Item "-d"
Toggles debug mode.  In debug mode, a full trace for the entire parse
is maintained in the \fI.sglr\-log\fR.  Be alert: such files tend to become
rather big.
.IP "\-\fBf\fR" 4
.IX Item "-f"
The parser applies a number of filters to ambiguous trees after the parsing
process has finished. Just supplying the \-\fBf\fR option toggles the application
of all filters. Specific filters can be toggled by using \-\fBf\fR with an
additional letter:
.Sp
.Vb 6
\& a : associativity        
\& d : direct eagerness    
\& e : eagerness          
\& i : injection count   
\& p : priority         
\& r : reject
.Ve
.Sp
.Vb 1
\& e.g., "sglr -fi" will toggle the injection count filter.
.Ve
.Sp
These specific toggles are supposed to be used for debugging purposes only.
So, do not use these options to tweak your language implementations! It is
highly probable that there will be no backward compatibility for them in 
future versions.
.IP "\-\fBi\fR \fIfile\fR" 4
.IX Item "-i file"
Read input from \fIfile\fR; by default, input is read from stdin.
.IP "\-\fB?\fR, \-\fBh\fR" 4
.IX Item "-?, -h"
Prints concise usage information (reflecting current setup).
.IP "\-\fBl\fR" 4
.IX Item "-l"
Toggles statistics mode (off by default).  Produces some run-time
statistics in \fIsglr\-stats.txt\fR, including time and \- on platforms
on which these can be obtained \- memory usage data.
.IP "\-\fBm\fR" 4
.IX Item "-m"
Generate AsFix2ME output format.  This is the default format.
.IP "\-\fBn\fR" 4
.IX Item "-n"
Toggles the contruction of the parse tree (on by default).  
.IP "\-\fBo\fR \fIfile\fR" 4
.IX Item "-o file"
Write output to \fIfile\fR; by default, output is written to stdout.
Note that strange things are bound to happen when writing binary
output to a tty.
.IP "\-\fBs\fR \fIsort\fR" 4
.IX Item "-s sort"
Only parse trees that have \fIsort\fR at their root are accepted.
.IP "\-\fBv\fR" 4
.IX Item "-v"
Toggles verbose operation.
.IP "\-\fBV\fR" 4
.IX Item "-V"
Displays the program's version number.
.SH "USAGE"
.IX Header "USAGE"
To parse, the \fBsglr\fR parser requires a parse table.  Instantiated with
that parse table, it has become a parser for the language defined by
the grammar corresponding to the specified parse table.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 11
\&    $ sglr -h
\&    Usage:
\&      sglr    -p file [-2?AbcdhlmntvV] [-f[adeirp]] [-i file] [-o file] \e
\&              [-s sort]
\&    [. . .]
\&    $ sglr -vp Test.tbl -i MyCode.cod -o Output.File -l
\&    sglr: logging to sglr-stats.txt
\&    sglr: opening parse table Test.tbl
\&    sglr: parsing file MyCode.cod (1 tokens)
\&    sglr: writing parse result to Output.File
\&    sglr: Test.tbl parsed MyCode.cod as sort S, exactly 0 ambiguities
.Ve
.SH "EXIT STATUS"
.IX Header "EXIT STATUS"
Returns an error on unsuccesful parses.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
sdf2table
.SH "REFERENCES"
.IX Header "REFERENCES"
	GraphViz: <http://www.research.att.com/sw/tools/graphviz/>

.SH "NOTES"
.IX Header "NOTES"
In a different context altogether, \fBsglr\fR runs as a \f(CW\*(C`ToolBus\*(C'\fR client.
.SH "MAINTAINER"
.IX Header "MAINTAINER"
Mark van den Brand <Mark.van.den.Brand@cwi.nl>
